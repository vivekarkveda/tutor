=== FINAL PROMPT SENT ===


You are a specialist in producing high-quality educational animations using Manim v0.19.0 (Python).
Your goal is to turn a provided topic script into a visually clear, accurate, and fully executable Python animation that communicates concepts step-by-step.
Follow these CRITICAL INSTRUCTIONS exactly as described:
...
Now, based on the following structured input:
CATALOG: {catalog}
SCRIPT_SEQ: 2
SCRIPT_FOR_MANIM: [
  "Start with the square and labels from Scene 1.",
  "Animate the square rotating 90 degrees clockwise.",
  "As it rotates, move the labels smoothly to their new positions.",
  "Highlight the new top-left corner label 'B' briefly.",
  "Repeat rotation and label adjustment for another 90 degrees, highlighting 'C'.",
  "Final rotation to highlight 'D', then return to original position with 'A' highlighted."
]
SCRIPT_VOICE_OVER: [
  "Now, let\u2019s see what happens when the square rotates.",
  "As the square turns 90 degrees clockwise, the labels shift accordingly.",
  "The new top-left corner is now labeled 'B'.",
  "Another 90-degree turn brings 'C' to the top-left.",
  "Finally, after one more turn, 'D' takes the top-left position.",
  "Returning to the original position, 'A' is back at the top-left corner."
]
SCRIPT_LENGTH: 40
Generate the FULL Manim Python code that:
- Follows all layout, geometry, boundary, and animation rules.
- Produces a step-by-step educational animation.
- Uses correct scaling and non-overlapping text.
- Is self-contained and executable without errors.
- Returns ONLY valid Python code (no explanations or Markdown formatting).
:pushpin: Previous Code (for continuity):
# Labels at Square Corners: Class 10 English

import numpy as np

class SquareCorners(Scene):
    def construct(self):
        # Start with a blank canvas
        self.wait()

        # Fade in title
        title = Text("Labels at Square Corners: Class 10 English", font_size=72).to_edge(UP)
        self.play(Write(title))
        self.wait()

        # Zoom out to reveal a square
        square = Square(fill_opacity=0.8, fill_color=BLUE_D)
        square.move_to(DOWN)
        self.play(FadeIn(square))
        self.wait()

        # Animate dots at corners
        dots = [Dot(point=corner, color=color) for corner, color in zip(square.get_corners(), [RED, GREEN, YELLOW, PURPLE])]
        self.play(*[GrowFromCenter(dot) for dot in dots])

        # Add labels next to dots
        labels = VGroup(*[Text(label, font_size=36).next_to(dot, RIGHT) for label, dot in zip('ABCD', dots)])
        self.play(Write(labels))

        # Highlight each label briefly
        for label in labels:
            self.play(FlashAround(label), run_time=1)
            self.wait(0.5)

# Run the animation
SquareCorners().render()


=== GENERATED CODE ===

```python
import numpy as np

class RotatingSquare(Scene):
    def construct(self):
        # Initialize objects from previous scene
        self.title = Text("Labels at Square Corners: Class 10 English", font_size=72).to_edge(UP)
        self.square = Square(fill_opacity=0.8, fill_color=BLUE_D)
        self.square.move_to(DOWN)
        self.dots = [Dot(point=corner, color=color) for corner, color in zip(self.square.get_corners(), [RED, GREEN, YELLOW, PURPLE])]
        self.labels = VGroup(*[Text(label, font_size=36).next_to(dot, RIGHT) for label, dot in zip('ABCD', self.dots)])

        # Start with the square and labels from Scene 1
        self.play(FadeIn(self.square), Write(self.labels))
        self.wait()

        # Animate the square rotating 90 degrees clockwise
        rotation_angle = 90 * DEGREES
        new_square = self.square.copy().rotate(rotation_angle)
        new_dots = [dot.copy().move_to(new_square.get_corner(corner)) for corner, dot in zip(range(4), self.dots)]
        new_labels = VGroup(*[label.copy().next_to(dot, RIGHT) for label, dot in zip(self.labels, new_dots)])

        self.play(
            Rotate(self.square, rotation_angle),
            Transform(self.dots, new_dots),
            Transform(self.labels, new_labels),
            run_time=2
        )

        # Highlight new top-left corner label 'B' briefly
        self.play(FlashAround(self.labels[1]), run_time=1)
        self.wait(0.5)

        # Repeat rotation and label adjustment for another 90 degrees
        rotation_angle = 90 * DEGREES
        new_square = new_square.copy().rotate(rotation_angle)
        new_dots = [dot.copy().move_to(new_square.get_corner(corner)) for corner, dot in zip(range(4), new_dots)]
        new_labels = VGroup(*[label.copy().next_to(dot, RIGHT) for label, dot in zip(new_labels, new_dots)])

        self.play(
            Rotate(new_square, rotation_angle),
            Transform(new_dots, new_dots),  # Keep dots in place
            Transform(new_labels, new_labels),
            run_time=2
        )
        self.play(FlashAround(new_labels[2]), run_time=1)
        self.wait(0.5)

        # Final rotation and highlight 'D'
        rotation_angle = 90 * DEGREES
        final_square = new_square.copy().rotate(rotation_angle)
        final_dots = [dot.copy().move_to(final_square.get_corner(corner)) for corner, dot in zip(range(4), new_dots)]
        final_labels = VGroup(*[label.copy().next_to(dot, RIGHT) for label, dot in zip(new_labels, final_dots)])

        self.play(
            Rotate(final_square, rotation_angle),
            Transform(final_dots, final_dots),
            Transform(final_labels, final_labels),
            run_time=2
        )
        self.play(FlashAround(final_labels[3]), run_time=1)
        self.wait()

        # Return to original position with 'A' highlighted
        self.play(
            Rotate(self.square, -360 * DEGREES),
            Transform(self.dots, self.dots),
            Transform(self.labels, self.labels),
            run_time=3
        )
        self.play(FlashAround(self.labels[0]), run_time=1)
        self.wait()

# Run the animation
RotatingSquare().render()
```