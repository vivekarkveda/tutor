=== FINAL PROMPT SENT ===

You are a specialist in producing high-quality educational animations using Manim v0.19.0 (Python).
Your task is to generate a complete, runnable Manim Python animation script based on the provided structured input.
Follow ALL instructions exactly — NO explanations, NO markdown, NO extra text.
Return ONLY the final Python code that can run successfully with:
    manim -pql <filename>.py <SceneName>
====================
OBJECTIVE
====================
copy the code from example if SCRIPT_SEQ is 1 then copy script 1
if SCRIPT_SEQ is 2 then copy script 2
====================
EXAMPLE (REFERENCE)
====================
[script 1 :- from manim import *
class ExpandingCircle(Scene):
    def construct(self):
        self.camera.background_color = "#1E1E1E"
        circle = Circle(radius=0.5, color=YELLOW)
        self.play(Create(circle), run_time=0.5)
        self.play(circle.animate.scale(2).fade(1), run_time=1.2)
        self.wait(0.3)
script 2 :- from manim import *
class MovingCircle(Scene):
    def construct(self):
        self.camera.background_color = "#1E1E1E"
        path = Circle(radius=2, color=GRAY, stroke_opacity=0.3)
        dot = Dot(color=RED).move_to(path.point_at_angle(0))
        self.add(path, dot)
        self.play(MoveAlongPath(dot, path), run_time=3, rate_func=linear)
        self.wait(0.3)
]
If the topic and script content match this example, reproduce this exact code — line by line.
====================
:inbox_tray: STRUCTURED INPUT
====================
catalog_placeholder: def construct(self):
        # Balloon body
        balloon = Circle(radius=0.3, color="#FF0000", fill_opacity=0.8)
        
        # Balloon string
        balloon_string = Line(ORIGIN, DOWN * 0.5, color="#808080", stroke_width=1)
        
        # Position balloon and string
        balloon.shift(RIGHT * 3 + UP * 1.5)
        balloon_string.next_to(balloon, DOWN, buff=0)
        
        # Group balloon and string
        balloon_group = VGroup(balloon, balloon_string)
        
        # Animate
        self.play(GrowFromCenter(balloon_group), run_time=1)
        self.wait(1)
Bug_fix_placeholder: # Original Bug Snippet:
```python
# Radius line (before)
radius_start = cylinder.get_zenith() + UP * (cylinder_height / 2)
radius_end = radius_start + RIGHT * cylinder_radius
radius_line = Line(
    radius_start,
    radius_end,
    color="#3498DB",
    stroke_width=6
)

# Top and bottom circles (before)
top_circle = Circle(
    radius=cylinder_radius,
    fill_color="#00FF00",
    fill_opacity=0.6,
    stroke_color="#00CC00",
    stroke_width=3
)
top_circle.rotate(90 * DEGREES, axis=RIGHT)
top_circle.shift(UP * (cylinder_height / 2 - 0.3))

bottom_circle = Circle(
    radius=cylinder_radius,
    fill_color="#00FF00",
    fill_opacity=0.6,
    stroke_color="#00CC00",
    stroke_width=3
)
bottom_circle.rotate(90 * DEGREES, axis=RIGHT)
bottom_circle.shift(DOWN * (cylinder_height / 2 + 0.3))

# Separation animation (before)
self.play(
    top_circle.animate.shift(UP * 0.8),
    bottom_circle.animate.shift(DOWN * 0.8),
    run_time=2.0
)
```

# Fixed Bug Snippet:
```python
# Axis and centers (after)
axis_dir = cylinder.get_direction()
axis_dir = axis_dir / np.linalg.norm(axis_dir)

top_center = cylinder.get_center() + axis_dir * (cylinder_height / 2 - 0.001)
bottom_center = cylinder.get_center() - axis_dir * (cylinder_height / 2 + 0.001)

# Radius line in face plane (after)
v = np.cross(axis_dir, UP)
if np.linalg.norm(v) < 1e-6:
    v = np.cross(axis_dir, RIGHT)
v = v / np.linalg.norm(v)

radius_start = top_center
radius_end = radius_start + v * cylinder_radius
radius_line = Line(radius_start, radius_end, color="#3498DB", stroke_width=6)

# Oriented top and bottom circles (after)
def orient_disc_to_normal(disc, n):
    n = n / np.linalg.norm(n)
    default = OUT
    axis = np.cross(default, n)
    if np.linalg.norm(axis) < 1e-6:
        angle = 0 if np.dot(default, n) > 0 else PI
        axis = RIGHT
    else:
        axis = axis / np.linalg.norm(axis)
        angle = np.arccos(np.dot(default, n))
    disc.rotate(angle, axis=axis)
    return disc

top_circle = Circle(
    radius=cylinder_radius,
    fill_color="#00FF00",
    fill_opacity=0.6,
    stroke_color="#00CC00",
    stroke_width=3
)
orient_disc_to_normal(top_circle, axis_dir).move_to(top_center)

bottom_circle = Circle(
    radius=cylinder_radius,
    fill_color="#00FF00",
    fill_opacity=0.6,
    stroke_color="#00CC00",
    stroke_width=3
)
orient_disc_to_normal(bottom_circle, axis_dir).move_to(bottom_center)

# Separation animation along cylinder axis (after)
self.play(
    top_circle.animate.shift(axis_dir * 0.8),
    bottom_circle.animate.shift(-axis_dir * 0.8),
    run_time=2.0
)
```
SCRIPT_SEQ: 1
SCRIPT_FOR_MANIM: [
  "Start with a blank canvas.",
  "Fade in the text 'Creating a Circle' in the center of the screen.",
  "Zoom out slightly to make space for the upcoming animation.",
  "Draw a small dot at the center of the screen, representing the center of the circle.",
  "Introduce a radius line extending from the center dot to the right.",
  "Animate the radius line rotating 360 degrees around the center dot, leaving a faint trace to form a circle.",
  "Thicken the trace to create a solid circle.",
  "Fade out the radius line, leaving only the circle on the screen."
]
SCRIPT_VOICE_OVER: [
  "Welcome to today's lesson on creating a circle.",
  "To begin, we need a center point.",
  "From this center, we extend a radius.",
  "As the radius rotates around the center, it traces the path of a circle.",
  "This path is then filled to form a complete circle.",
  "Now, we have a perfect circle ready for further exploration."
]
SCRIPT_LENGTH: 30 seconds
Previous Code (for continuity):

====================
:gear: OUTPUT REQUIREMENTS
====================
just copy the code provided in EXAMPLE (REFERENCE)

=== GENERATED CODE ===

from manim import *

class ExpandingCircle(Scene):
    def construct(self):
        self.camera.background_color = "#1E1E1E"
        circle = Circle(radius=0.5, color=YELLOW)
        self.play(Create(circle), run_time=0.5)
        self.play(circle.animate.scale(2).fade(1), run_time=1.2)
        self.wait(0.3)