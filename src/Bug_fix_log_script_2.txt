=== FINAL PROMPT SENT ===

You are a specialist in producing high-quality educational animations using Manim v0.19.0 (Python).
Your task is to generate a complete, runnable Manim Python animation script based on the provided structured input.
Follow ALL instructions exactly — NO explanations, NO markdown, NO extra text.
Return ONLY the final Python code that can run successfully with:
    manim -pql <filename>.py <SceneName>
====================
OBJECTIVE
====================
copy the code from example if SCRIPT_SEQ is 1 then copy script 1
if SCRIPT_SEQ is 2 then copy script 2
====================
EXAMPLE (REFERENCE)
====================
[script 1 :- from manim import *
class ExpandingCircle(Scene):
    def construct(self):
        self.camera.background_color = "#1E1E1E"
        circle = Circle(radius=0.5, color=YELLOW)
        self.play(Create(circle), run_time=0.5)
        self.play(circle.animate.scale(2).fade(1), run_time=1.2)
        self.wait(0.3)
script 2 :- from manim import *
class MovingCircle(Scene):
    def construct(self):
        self.camera.background_color = "#1E1E1E"
        path = Circle(radius=2, color=GRAY, stroke_opacity=0.3)
        dot = Dot(color=RED).move_to(path.point_at_angle(0))
        self.add(path, dot)
        self.play(MoveAlongPath(dot, path), run_time=3, rate_func=linear)
        self.wait(0.3)
]
If the topic and script content match this example, reproduce this exact code — line by line.
====================
:inbox_tray: STRUCTURED INPUT
====================
catalog_placeholder: def construct(self):
        # Balloon body
        balloon = Circle(radius=0.3, color="#FF0000", fill_opacity=0.8)
        
        # Balloon string
        balloon_string = Line(ORIGIN, DOWN * 0.5, color="#808080", stroke_width=1)
        
        # Position balloon and string
        balloon.shift(RIGHT * 3 + UP * 1.5)
        balloon_string.next_to(balloon, DOWN, buff=0)
        
        # Group balloon and string
        balloon_group = VGroup(balloon, balloon_string)
        
        # Animate
        self.play(GrowFromCenter(balloon_group), run_time=1)
        self.wait(1)
Bug_fix_placeholder: # Original Bug Snippet:
```python
# Radius line (before)
radius_start = cylinder.get_zenith() + UP * (cylinder_height / 2)
radius_end = radius_start + RIGHT * cylinder_radius
radius_line = Line(
    radius_start,
    radius_end,
    color="#3498DB",
    stroke_width=6
)

# Top and bottom circles (before)
top_circle = Circle(
    radius=cylinder_radius,
    fill_color="#00FF00",
    fill_opacity=0.6,
    stroke_color="#00CC00",
    stroke_width=3
)
top_circle.rotate(90 * DEGREES, axis=RIGHT)
top_circle.shift(UP * (cylinder_height / 2 - 0.3))

bottom_circle = Circle(
    radius=cylinder_radius,
    fill_color="#00FF00",
    fill_opacity=0.6,
    stroke_color="#00CC00",
    stroke_width=3
)
bottom_circle.rotate(90 * DEGREES, axis=RIGHT)
bottom_circle.shift(DOWN * (cylinder_height / 2 + 0.3))

# Separation animation (before)
self.play(
    top_circle.animate.shift(UP * 0.8),
    bottom_circle.animate.shift(DOWN * 0.8),
    run_time=2.0
)
```

# Fixed Bug Snippet:
```python
# Axis and centers (after)
axis_dir = cylinder.get_direction()
axis_dir = axis_dir / np.linalg.norm(axis_dir)

top_center = cylinder.get_center() + axis_dir * (cylinder_height / 2 - 0.001)
bottom_center = cylinder.get_center() - axis_dir * (cylinder_height / 2 + 0.001)

# Radius line in face plane (after)
v = np.cross(axis_dir, UP)
if np.linalg.norm(v) < 1e-6:
    v = np.cross(axis_dir, RIGHT)
v = v / np.linalg.norm(v)

radius_start = top_center
radius_end = radius_start + v * cylinder_radius
radius_line = Line(radius_start, radius_end, color="#3498DB", stroke_width=6)

# Oriented top and bottom circles (after)
def orient_disc_to_normal(disc, n):
    n = n / np.linalg.norm(n)
    default = OUT
    axis = np.cross(default, n)
    if np.linalg.norm(axis) < 1e-6:
        angle = 0 if np.dot(default, n) > 0 else PI
        axis = RIGHT
    else:
        axis = axis / np.linalg.norm(axis)
        angle = np.arccos(np.dot(default, n))
    disc.rotate(angle, axis=axis)
    return disc

top_circle = Circle(
    radius=cylinder_radius,
    fill_color="#00FF00",
    fill_opacity=0.6,
    stroke_color="#00CC00",
    stroke_width=3
)
orient_disc_to_normal(top_circle, axis_dir).move_to(top_center)

bottom_circle = Circle(
    radius=cylinder_radius,
    fill_color="#00FF00",
    fill_opacity=0.6,
    stroke_color="#00CC00",
    stroke_width=3
)
orient_disc_to_normal(bottom_circle, axis_dir).move_to(bottom_center)

# Separation animation along cylinder axis (after)
self.play(
    top_circle.animate.shift(axis_dir * 0.8),
    bottom_circle.animate.shift(-axis_dir * 0.8),
    run_time=2.0
)
```
SCRIPT_SEQ: 2
SCRIPT_FOR_MANIM: [
  "Start with the final frame of Scene 1: the highlighted circle.",
  "Zoom in slightly on the circle to focus attention.",
  "Label the center of the circle as 'O'.",
  "Draw a radius from the center to the edge of the circle, labeling it 'r'.",
  "Animate a point moving along the circumference, leaving a trail to show the circle's boundary.",
  "Label this moving point as 'P'.",
  "Draw a line from 'O' to 'P', emphasizing the radius.",
  "Fade in the equation 'Circumference = 2\u03c0r' below the circle, with each symbol animating in sequentially."
]
SCRIPT_VOICE_OVER: [
  "Now that we\u2019ve created our circle, let\u2019s break down its key components.",
  "The center of the circle is labeled as 'O'.",
  "The radius, extending from the center to any point on the edge, is denoted as 'r'.",
  "Imagine a point 'P' moving along the circumference of the circle.",
  "The distance from the center 'O' to any point 'P' on the circle is always equal to the radius 'r'.",
  "One of the most important formulas related to circles is the circumference, calculated as 2 times \u03c0 times the radius.",
  "This equation helps us determine the total distance around the circle."
]
SCRIPT_LENGTH: 30 seconds
Previous Code (for continuity):
from manim import *

class ExpandingCircle(Scene):
    def construct(self):
        self.camera.background_color = "#1E1E1E"
        circle = Circle(radius=0.5, color=YELLOW)
        self.play(Create(circle), run_time=0.5)
        self.play(circle.animate.scale(2).fade(1), run_time=1.2)
        self.wait(0.3)
====================
:gear: OUTPUT REQUIREMENTS
====================
just copy the code provided in EXAMPLE (REFERENCE)

=== GENERATED CODE ===

from manim import *

class MovingCircle(Scene):
    def construct(self):
        self.camera.background_color = "#1E1E1E"
        path = Circle(radius=2, color=GRAY, stroke_opacity=0.3)
        dot = Dot(color=RED).move_to(path.point_at_angle(0))
        self.add(path, dot)
        self.play(MoveAlongPath(dot, path), run_time=3, rate_func=linear)
        self.wait(0.3)