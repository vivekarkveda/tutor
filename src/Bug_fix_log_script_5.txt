=== FINAL PROMPT SENT ===

Role :-
You are a specialist in producing high-quality educational animations using Manim v0.19.0 (Python).
Your job is to convert a provided topic script into a visually clear, accurate, and fully executable Manim Python file that a beginner can run. Produce only the Python code as the final output (no explanations, no comments).
Essential Guidelines :-
Complete and runnable code
Output must be self-contained, error-free, and executable by a beginner in Manim.
Include all necessary imports, class definitions, and the construct method.
Frame management and positioning :-
CRITICAL: All objects must remain fully visible within the frame at all times.
Keep objects inside safe bounds (X, Y ∈ [-5, 5]) to prevent clipping.
Auto-scale objects where necessary to prevent any part from going off-screen.
Use .scale() method to reduce size of oversized objects before positioning.
Test all coordinates to ensure they stay within visible bounds.
Use .get_center(), .get_edge_center(), or .get_boundary_point() methods for accurate positioning.
ALWAYS use this layout for ALL content types (diagrams, tables, graphs, equations, etc.):
- LEFT 60-65% of screen: Main content (diagram/table/graph/any mathematical figure)
- RIGHT 35-40% of screen: Text explanations only
Zone Definitions ;-
Left Content Zone: For ALL visual content
- X position range: -6.5 to 0
- Y position range: -3.5 to 3.5
- Takes 60-65% of screen width
- Use for: diagrams, tables, graphs, equations, shapes, animations, data displays
Right Text Zone: For necessary on-screen text explanations and annotations only
X position range: 1.5 to 6.5
Y position range: -3.5 to 3.5
Takes: 35–40% of screen width
Use for:
Explanations of visual steps
Key definitions or important mathematical notes
Annotation of important objects or procedures
Bullet points about steps in a process
Conclusions or summary statements
All other explanatory text essential for understanding the visual content
Do NOT use for:
Full voice-over/narration script (unless explicitly requested)
Title Zone (Optional): Y = 3.8 using .to_edge(UP, buff=0.2) - spans full width if needed
Layout and text overlap prevention :-
MANDATORY: Text must NEVER overlap with diagrams, objects, or other text.
Use .arrange(), .next_to(), or .shift() with adequate spacing (buff ≥ 0.8).
Center objects by default unless specified otherwise.
Place text labels at sufficient distance from objects (buff ≥ 1.0) to prevent overlap.
If there is insufficient space for text labels, prioritize the most important labels and remove less critical text.
Use strategic positioning: place labels above, below, left, or right of objects where space permits.
For point labels or annotations near multiple objects, alternate sides (LEFT/RIGHT or UP/DOWN) to prevent clustering.
For complex diagrams, use leader lines or arrows to connect distant labels to their objects.
Do not include unnecessary background shapes.
Text management and clarity:-
Check text positioning after each object placement to ensure no overlaps.
Text should appear near related objects without covering them or other text.
If no figure exists, center the text.
Use VGroup and .arrange() for alignment with proper spacing.
When multiple text elements exist, arrange them in non-overlapping positions using .arrange(DOWN, buff=0.5) or similar.
Consider using smaller font sizes (scale=0.8 or scale=0.6) if needed to fit text properly.
For measurement labels (e.g., "10 cm", "5 units"), position them to the side (LEFT/RIGHT) of horizontal objects or above/below for vertical objects.
Mathematical and geometric accuracy :-
CRITICAL: When creating geometric shapes that must satisfy mathematical relationships (circles, triangles, polygons, etc.), calculate positions using proper mathematical formulas.
For objects that must lie ON other objects (e.g., points on circles, vertices on curves), use the object's mathematical properties to calculate exact positions.
Do not use arbitrary or estimated positions when mathematical precision is required.
Verify that calculated positions satisfy the defining equations or constraints of the shapes.
Use numpy functions (np.sqrt, np.sin, np.cos, etc.) for accurate calculations.
Proportional relationships :-
When dealing with measurements or sizes with specific values (e.g., "10 cm" vs "24 cm"), maintain their proportional relationships accurately.
Scale all related objects proportionally to fit within the frame while preserving their relative sizes.
Larger values should visually appear larger; smaller values should appear smaller in proportion.
Animation behavior :-
Animate appearances and transformations using self.play.
Include smooth animations: FadeIn, FadeOut, Write, Transform, ReplacementTransform, Create, GrowFromCenter, etc.
Include short pauses to emphasize points.
Introduce one idea at a time.
Automatically pace each animation so that the total video duration is between 30-45 seconds and aligns with the voice-over.
Timing rules for exact duration (30-45 seconds) :-
Count all animation actions in SCRIPT FOR MANIM (each FadeIn, Write, Create, Transform, etc.).
Let n = number of animation actions.
Target duration should be between 30-45 seconds per scene based on content complexity.
Compute base_time_per_action = target_duration ÷ n.
Apply run_time for each animation step = base_time_per_action × complexity_factor (1 for normal, >1 for multi-step animations).
Add short .wait() pauses (0.3–0.7 sec) proportionally scaled so that the sum of all run_time + wait falls within 30-45 seconds.
Ensure each step duration roughly matches the length of the corresponding narration in SCRIPT VOICE OVER
Adjust all times automatically to fall within the 30-45 second range, allowing flexibility based on content complexity.
Visual styling and screen boundaries :-
Use colors (hex values), arrows, highlights, semi-transparent fills.
Maintain consistent visual style throughout.
Double-check that all visual elements fit within screen boundaries before finalizing positions.
Use .get_boundary_point() or .get_edge_center() methods to position objects relative to screen edges safely.
Coding conventions :-
Name each class using SCRIPT SEQ (e.g., ScriptStep2).
Use supported Manim primitives: Line, Dot, Circle, Polygon, Rectangle, Square, Arrow, Text, MathTex, NumberPlane, Triangle, VGroup.
Avoid deprecated methods and out-of-bounds operations.
Always include bounds checking in your positioning logic.
Topic constraints and quality assurance:-
Remove unnecessary background shapes.
FINAL CHECK: Ensure all text labels are positioned clearly outside objects with no overlaps.
FINAL CHECK: Ensure all objects and text remain within screen boundaries.
FINAL CHECK: If there is not enough space for all text, remove less important text elements.
FINAL CHECK: Verify mathematical accuracy - objects that should lie on other objects must be calculated to do so precisely.
FINAL CHECK: Verify proportional relationships are maintained for all measurements and sizes.
Write hex values for all colors used
Placeholders :-
catalog_placeholder: def construct(self):
        # Balloon body
        balloon = Circle(radius=0.3, color="#FF0000", fill_opacity=0.8)
        
        # Balloon string
        balloon_string = Line(ORIGIN, DOWN * 0.5, color="#808080", stroke_width=1)
        
        # Position balloon and string
        balloon.shift(RIGHT * 3 + UP * 1.5)
        balloon_string.next_to(balloon, DOWN, buff=0)
        
        # Group balloon and string
        balloon_group = VGroup(balloon, balloon_string)
        
        # Animate
        self.play(GrowFromCenter(balloon_group), run_time=1)
        self.wait(1)
Bug_fix_placeholder: # Original Bug Snippet:
```python
angle_arc = Arc(
    radius=0.8,
    start_angle=0,
    angle=PI/4,
    color="#008000",
    stroke_width=4
)
angle_arc.move_arc_center_to(head.get_center())

angle_highlight = Arc(
    radius=0.9,
    start_angle=0,
    angle=PI/4,
    color="#FFFF00",
    stroke_width=6,
    stroke_opacity=0.7
)
angle_highlight.move_arc_center_to(head.get_center())
```

# Fixed Bug Snippet:
```python
# Calculate angle of sight line relative to horizontal
sight_vec = balloon.get_center() - head.get_center()
sight_angle = np.arctan2(sight_vec[1], sight_vec[0])  # in radians

# Angle arcs aligned with sight line
angle_arc = Arc(
    radius=0.8,
    start_angle=0,
    angle=sight_angle,
    color="#008000",
    stroke_width=4
)
angle_arc.move_arc_center_to(head.get_center())

angle_highlight = Arc(
    radius=0.9,
    start_angle=0,
    angle=sight_angle,
    color="#FFFF00",
    stroke_width=6,
    stroke_opacity=0.7
)
angle_highlight.move_arc_center_to(head.get_center())

# Angle label dynamically placed
angle_deg = int(np.degrees(sight_angle))
angle_label = MathTex(f"{angle_deg}°", color="#008000", font_size=28)
label_offset = 1.0
angle_label.move_to(head.get_center() + label_offset * np.array([np.cos(sight_angle/2), np.sin(sight_angle/2), 0]))
```
SCRIPT_SEQ: 5
SCRIPT_FOR_MANIM: [
  "Transition back to the target, with the successful arrow still in place.",
  "Animate the target transforming into a 3D object, rotating slightly to show depth.",
  "Introduce a new element, a moving ring, starting from the outer circle and shrinking towards the center.",
  "As the ring shrinks, highlight the areas it touches, emphasizing the precision required.",
  "End with the ring at the center, overlapping the arrow's tip, creating a glowing effect."
]
SCRIPT_VOICE_OVER: [
  "Returning to our visual target, we add a new dimension, literally. The flat surface transforms into a 3D space.",
  "Now, imagine a moving ring, a dynamic element, starting its journey from the outer circle.",
  "As it shrinks, it challenges the arrow's precision. The areas it touches require utmost accuracy.",
  "The ring's path demands focus, narrowing down to the center, the ultimate test of precision.",
  "Finally, it reaches the bullseye, overlapping the arrow's tip, a brilliant display of accuracy and precision."
]
SCRIPT_LENGTH: 35s
Previous Code (for continuity):
import numpy as np

from manim import *


class ScriptStep4(Scene):
    def construct(self):
        # Colors
        BLUE = "#007BFF"
        GREEN = "#28A745"
        RED = "#FF4500"
        YELLOW = "#FFC107"

        # Constants
        SCREEN_WIDTH = 16
        SCREEN_HEIGHT = 9
        LEFT_ZONE_WIDTH = 0.65 * SCREEN_WIDTH
        RIGHT_ZONE_WIDTH = 0.4 * SCREEN_WIDTH
        TEXT_BUFFER = 0.8

        # Title
        title = Tex(
            "Understanding the Bell Curve",
            color=BLUE,
            font_size=40
        ).to_edge(UP)

        # Step 1: Bell curve
        bell_curve = VGroup()
        bell_curve_x = np.linspace(-3, 3, 100)
        bell_curve_y = np.exp(-bell_curve_x**2 / 2) / np.sqrt(2 * np.pi)
        for x, y in zip(bell_curve_x, bell_curve_y):
            dot = Dot(color=YELLOW, radius=0.05)
            dot.move_to(RIGHT * x + UP * y)
            bell_curve.add(dot)

        bell_curve.move_to(LEFT * (LEFT_ZONE_WIDTH / 2))

        # Bell curve labels
        x_label = Tex("Accuracy", color=YELLOW, font_size=20).next_to(bell_curve, DOWN, buff=0.5)
        y_label = Tex("Frequency", color=YELLOW, font_size=20).next_to(bell_curve, LEFT, buff=0.5)

        # Step 2: Vertical line at peak
        peak_x = bell_curve_x[np.argmax(bell_curve_y)]
        peak_y = bell_curve_y.max()
        peak_line = Line(RIGHT * peak_x, UP * peak_y, color=RED)

        # Step 3: Moving pointer
        pointer_start = LEFT * (LEFT_ZONE_WIDTH / 2)
        pointer_end = RIGHT * peak_x
        pointer = Line(pointer_start, pointer_end, color=GREEN)

        # Step 4: Highlighted areas
        highlighted_areas = VGroup()
        for dot in bell_curve:
            distance = np.linalg.norm(dot.get_center() - pointer.get_end())
            opacity = 1 - distance / 2  # Adjust opacity based on distance
            highlighted_area = Rectangle(
                width=0.1,
                height=bell_curve_y.max() - dot.get_center()[1],
                color=GREEN,
                fill_opacity=opacity,
                stroke_width=0
            )
            highlighted_area.move_to(dot.get_center())
            highlighted_areas.add(highlighted_area)

        # Animate
        self.add(title)
        self.play(
            LaggedStart(
                *[GrowFromCenter(dot) for dot in bell_curve],
                lag_ratio=0.1,
                run_time=3
            ),
            LaggedStart(
                Write(x_label),
                Write(y_label),
                lag_ratio=0.5,
                run_time=1
            )
        )
        self.play(GrowFromCenter(peak_line))
        self.play(
            GrowFromCenter(pointer),
            LaggedStart(
                *[GrowFromCenter(area) for area in highlighted_areas],
                lag_ratio=0.1,
                run_time=3
            ),
            run_time=5
        )
        self.wait(2)
Procedure:-
Read SCRIPT FOR MANIM carefully and identify the mathematical/geometric requirements.
Calculate all positions mathematically where precision is required (don't estimate).
Generate Manim code that is fully frame-safe and visually clear.
Prioritize preventing overlaps: text-to-text, text-to-diagram, and object-to-object.
Ensure all elements stay within screen boundaries through proper scaling and positioning.
Verify proportional relationships are maintained for measurements and sizes.
Animate step-by-step according to instructions.
Set run_time and .wait() durations for total animation duration between 30-45 seconds, matching SCRIPT VOICE OVER pacing.
Name classes using SCRIPT SEQ.
Only include shapes necessary for the topic.
Perform final quality checks for overlaps, boundary violations, and mathematical accuracy.
Additional Instructions :-
Generate only the Manim Python code.
Do not include explanations, comments, or extra text outside the code.
Code must be overlap-free, screen-boundary compliant, and mathematically accurate.
All geometric relationships must be calculated, not approximated
Common Errors to avoid :-
TypeError: Mobject.__init__() got an unexpected keyword argument 'weight'
IndexError: list index out of range
ValueError: latex error converting to dvi. See log output above or the log file: media\Tex\b92e2d7f7f7a1052.log
NameError: name 'run_time' is not defined

=== GENERATED CODE ===

```python
import numpy as np

from manim import *


class ScriptStep5(Scene):
    def construct(self):
        # Colors
        BLUE = "#007BFF"
        GREEN = "#28A745"
        RED = "#FF4500"
        YELLOW = "#FFC107"

        # Constants
        SCREEN_WIDTH = 16
        SCREEN_HEIGHT = 9
        LEFT_ZONE_WIDTH = 0.6 * SCREEN_WIDTH
        RIGHT_ZONE_WIDTH = 0.4 * SCREEN_WIDTH
        TEXT_BUFFER = 0.8

        # Title
        title = Tex(
            "3D Target Transformation",
            color=BLUE,
            font_size=40
        ).to_edge(UP)

        # Step 1: Target
        target = Circle(radius=2, color=RED)
        target_3d = Cube(fill_color=RED, fill_opacity=0.8, stroke_width=2)

        # Step 2: Successful arrow
        arrow = Arrow(ORIGIN, RIGHT * 2, color=GREEN)

        # Step 3: Moving ring
        ring = Circle(radius=2, color=YELLOW, stroke_width=4)
        ring_path = TracedPath(ring.get_center, stroke_color=YELLOW)

        # Step 4: Highlighted areas
        highlighted_areas = VGroup()
        for i in np.linspace(0, 1, 100):
            area = Circle(radius=2 - i, color=YELLOW, fill_opacity=0.5)
            highlighted_areas.add(area)

        # Animate
        self.add(title)
        self.play(FadeIn(target))
        self.play(
            Transform(target, target_3d),
            run_time=2
        )
        self.play(
            GrowArrow(arrow),
            run_time=1
        )
        self.play(
            ShowCreation(ring_path),
            LaggedStart(
                *[FadeIn(area) for area in highlighted_areas],
                lag_ratio=0.1,
                run_time=3
            ),
            run_time=5
        )
        self.play(
            Transform(ring, highlighted_areas[-1]),
            run_time=2
        )
        self.wait(1)
```